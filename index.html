<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Night Walk — Trees, House, Fireflies</title>
<style>
  html, body { height: 100%; margin: 0; background: #03060b; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; color: #eaf6ff; }
  #overlay {
    position: fixed; inset: 0; display: grid; place-items: center;
    background: radial-gradient(1200px 700px at 50% -10%, #1b2b5566, transparent 55%), #03060bf0;
    user-select: none; z-index: 10;
  }
  .panel {
    width: min(720px, 92vw);
    background: #0a1328cc; border: 1px solid #ffffff22; border-radius: 16px;
    padding: 18px 18px 16px; backdrop-filter: blur(8px) saturate(115%);
    box-shadow: 0 20px 50px rgba(0,0,0,.45);
  }
  h1 { margin: 6px 0 8px; font-size: clamp(20px, 3vw, 28px); letter-spacing: .4px }
  .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; color: #bcd1ff }
  .kbd {
    display:inline-flex; align-items:center; justify-content:center; padding: 4px 8px; min-width: 26px;
    background:#0d1b41; border:1px solid #ffffff22; border-radius: 6px; font-weight:700; letter-spacing:.3px
  }
  .btn {
    appearance:none; border:none; padding: 10px 14px; border-radius: 10px; font-weight: 800;
    cursor: pointer; background: linear-gradient(180deg,#8ad3ff,#39a8ff); color:#04121c; box-shadow: 0 10px 20px #0091ff33;
  }
  #hud {
    position: fixed; left: 10px; bottom: 10px; z-index: 2; color: #bcd1ff; font-size: 12.5px;
    padding: 6px 8px; background: #0a1328aa; border:1px solid #ffffff22; border-radius: 8px; backdrop-filter: blur(6px);
  }
  #hint { color: #8fb6ff }
  #flashState { color: #ffe28f }
</style>
</head>
<body>
<div id="overlay">
  <div class="panel">
    <h1>Night Walk</h1>
    <div class="row">Explore a medium-sized world with trees, rocks, a cozy house, fog and moonlight. 100 fireflies blink and wander. Toggle your flashlight for vibes.</div>
    <div style="height:8px"></div>
    <div class="row">
      <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span> Move
      <span class="kbd">Mouse</span> Look
      <span class="kbd">Shift</span> Sprint
      <span class="kbd">F</span> Flashlight
      <span class="kbd">H</span> Help
      <span class="kbd">Esc</span> Unlock
    </div>
    <div style="height:10px"></div>
    <button class="btn" id="startBtn">Click to Play</button>
  </div>
</div>

<div id="hud">
  <span id="hint">WASD + Mouse • F: Flashlight • H: Help • Esc: Unlock</span>
  <span> • Flashlight: <b id="flashState">ON</b></span>
</div>

<script type="module">
/* Minimal 3D night walk with trees, rocks, house, fog, stars and fireflies.
   Requires internet to load Three.js modules from unpkg. Save as an HTML file and open.
*/
import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';
import { PointerLockControls } from 'https://unpkg.com/three@0.159.0/examples/jsm/controls/PointerLockControls.js';

const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const flashStateEl = document.getElementById('flashState');

const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x05070c);
scene.fog = new THREE.FogExp2(0x04070d, 0.0085);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0, 1.7, 6);

// Controls
const controls = new PointerLockControls(camera, renderer.domElement);
controls.getObject().position.set(0, 1.7, 0);

startBtn.addEventListener('click', () => {
  controls.lock();
});
controls.addEventListener('lock', () => overlay.style.display = 'none');
controls.addEventListener('unlock', () => overlay.style.display = 'grid');

// Resize
addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// Physically-correctish lighting setup
renderer.physicallyCorrectLights = true;

// Sky stars
{
  const starCount = 1200;
  const positions = new Float32Array(starCount * 3);
  for (let i=0;i<starCount;i++){
    const r = 900 + Math.random()*400;
    const theta = Math.random()*Math.PI*2;
    const phi = Math.random()*Math.PI*0.45; // upper sky
    const x = r * Math.cos(theta) * Math.sin(phi);
    const y = r * Math.cos(phi);
    const z = r * Math.sin(theta) * Math.sin(phi);
    positions[i*3+0]=x; positions[i*3+1]=Math.abs(y)+120; positions[i*3+2]=z;
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const mat = new THREE.PointsMaterial({ color: 0xbfdcff, size: 1.2, sizeAttenuation: true, transparent: true, opacity: 0.9 });
  const stars = new THREE.Points(geo, mat);
  scene.add(stars);
}

// Lights: faint ambient, moon directional, house glow, flashlight
const hemi = new THREE.HemisphereLight(0x223a66, 0x0a0c10, 0.15);
scene.add(hemi);

const moonLight = new THREE.DirectionalLight(0xb8cfff, 1.2);
moonLight.position.set(-80, 120, -60);
moonLight.castShadow = true;
moonLight.shadow.mapSize.set(2048, 2048);
moonLight.shadow.camera.left = -200; moonLight.shadow.camera.right = 200;
moonLight.shadow.camera.top = 200; moonLight.shadow.camera.bottom = -200;
moonLight.shadow.bias = -0.00008;
scene.add(moonLight);
scene.add(moonLight.target);
moonLight.target.position.set(0, 0, 0);

// Little moon mesh
{
  const moon = new THREE.Mesh(
    new THREE.SphereGeometry(5, 32, 32),
    new THREE.MeshBasicMaterial({ color: 0xdde9ff })
  );
  moon.position.copy(moonLight.position).multiplyScalar(0.9);
  scene.add(moon);
}

// World/terrain
const WORLD_SIZE = 360;             // total width/length
const HALF = WORLD_SIZE/2;
const PLAYER_EYE = 1.7;

// Height function (keep cheap but organic)
function heightAt(x, z){
  // scaled coords
  const sx = x * 0.03, sz = z * 0.03;
  const h = Math.sin(sx*1.2) * Math.cos(sz*1.1) * 0.9
          + Math.sin((sx+sz)*0.7) * 0.6
          + Math.cos(sx*0.35 - sz*0.6) * 0.4;
  return h * 0.8; // amplitude
}

const groundGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 180, 180);
groundGeo.rotateX(-Math.PI/2);
{
  const pos = groundGeo.attributes.position;
  for (let i=0;i<pos.count;i++){
    const x = pos.getX(i), z = pos.getZ(i);
    pos.setY(i, heightAt(x, z));
  }
  pos.needsUpdate = true;
  groundGeo.computeVertexNormals();
}

const groundMat = new THREE.MeshStandardMaterial({
  color: 0x223d23,
  roughness: 1.0, metalness: 0.0
});
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.receiveShadow = true;
scene.add(ground);

// Border: visible fence line + clamp
{
  const borderGeo = new THREE.BufferGeometry();
  const verts = new Float32Array([
    -HALF, 0.05, -HALF,
     HALF, 0.05, -HALF,
     HALF, 0.05,  HALF,
    -HALF, 0.05,  HALF,
    -HALF, 0.05, -HALF
  ]);
  borderGeo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
  const borderMat = new THREE.LineBasicMaterial({ color: 0x3b70ff, linewidth: 2, transparent: true, opacity: 0.5 });
  const border = new THREE.Line(borderGeo, borderMat);
  scene.add(border);
}

// House (simple cozy hut with warm interior light)
const house = new THREE.Group();
(function buildHouse(){
  const baseW = 10, baseH = 4.2, baseD = 8;
  const base = new THREE.Mesh(
    new THREE.BoxGeometry(baseW, baseH, baseD),
    new THREE.MeshStandardMaterial({ color: 0x20324c, roughness: 0.8, metalness: 0.05 })
  );
  base.castShadow = true; base.receiveShadow = true;
  base.position.y = baseH/2;

  const roof = new THREE.Mesh(
    new THREE.ConeGeometry(Math.max(baseW, baseD)*0.7, 3.8, 4),
    new THREE.MeshStandardMaterial({ color: 0x3b2e2a, roughness: 0.9, metalness: 0.0 })
  );
  roof.castShadow = true;
  roof.position.y = baseH + 1.9;
  roof.rotation.y = Math.PI/4;

  // Simple windows (emissive quads)
  const winMat = new THREE.MeshStandardMaterial({ color: 0x222222, emissive: 0xffcc88, emissiveIntensity: 2, metalness: 0, roughness: 0.6 });
  const win = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 1.2), winMat);
  win.position.set(0, baseH*0.55, baseD/2 + 0.01);
  const win2 = win.clone(); win2.position.z = -baseD/2 - 0.01; win2.rotation.y = Math.PI;

  const door = new THREE.Mesh(
    new THREE.PlaneGeometry(1.6, 2.6),
    new THREE.MeshStandardMaterial({ color: 0x181818, roughness: 1 })
  );
  door.position.set(-baseW/3, baseH*0.55, baseD/2 + 0.02);

  // Warm interior point light
  const warm = new THREE.PointLight(0xffcc88, 25, 36, 2);
  warm.castShadow = true;
  warm.shadow.mapSize.set(1024,1024);
  warm.position.set(0, baseH*0.8, 0);

  house.add(base, roof, win, win2, door, warm);
  // Place the house slightly off-center on higher ground
  const hx = -WORLD_SIZE*0.18, hz = WORLD_SIZE*0.15;
  house.position.set(hx, heightAt(hx, hz), hz);
  scene.add(house);
})();

// Random trees
function createTree(){
  const g = new THREE.Group();
  const h = THREE.MathUtils.randFloat(4.2, 8.5);
  const trunkR = THREE.MathUtils.randFloat(0.18, 0.35);
  const trunk = new THREE.Mesh(
    new THREE.CylinderGeometry(trunkR*0.7, trunkR, h, 8),
    new THREE.MeshStandardMaterial({ color: 0x584330, roughness: 0.9 })
  );
  trunk.castShadow = true; trunk.receiveShadow = true;
  trunk.position.y = h/2;

  const foliageMat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(THREE.MathUtils.randFloat(0.28,0.36), 0.7, 0.22), roughness: 1, metalness: 0 });
  const cones = new THREE.Group();
  const c1 = new THREE.Mesh(new THREE.ConeGeometry(h*0.25, h*0.45, 10), foliageMat);
  const c2 = c1.clone(); const c3 = c1.clone();
  c1.position.y = h*0.65;
  c2.position.y = h*0.9; c2.scale.set(0.85,0.85,0.85);
  c3.position.y = h*1.08; c3.scale.set(0.65,0.65,0.65);
  [c1,c2,c3].forEach(c=>{ c.castShadow=true; c.receiveShadow=false; });
  cones.add(c1,c2,c3);

  g.add(trunk, cones);
  return g;
}

function dist2(a,b){ const dx=a.x-b.x, dz=a.z-b.z; return dx*dx+dz*dz; }

// Populate trees
{
  const treeCount = 140;
  const trees = new THREE.Group();
  const avoid = new THREE.Vector3().copy(house.position);
  for (let i=0;i<treeCount;i++){
    let x=0,z=0, tries=0;
    do{
      x = THREE.MathUtils.randFloatSpread(WORLD_SIZE-20);
      z = THREE.MathUtils.randFloatSpread(WORLD_SIZE-20);
      tries++;
    } while ((dist2({x,z}, {x:avoid.x, z:avoid.z}) < 45*45 || Math.abs(x)<8 && Math.abs(z)<8) && tries < 20);
    const t = createTree();
    const y = heightAt(x,z);
    t.position.set(x, y, z);
    t.rotation.y = Math.random()*Math.PI*2;
    trees.add(t);
  }
  scene.add(trees);
}

// Random rocks
function createRock(){
  const g = new THREE.Mesh(
    new THREE.IcosahedronGeometry(1, 1),
    new THREE.MeshStandardMaterial({ color: 0x6b7078, roughness: 1 })
  );
  const s = THREE.MathUtils.randFloat(0.4, 1.6);
  g.scale.set(s * THREE.MathUtils.randFloat(0.8,1.3), s * THREE.MathUtils.randFloat(0.7,1.2), s * THREE.MathUtils.randFloat(0.8,1.4));
  g.castShadow = true; g.receiveShadow = true;
  return g;
}
{
  const rockCount = 80;
  const rocks = new THREE.Group();
  for (let i=0;i<rockCount;i++){
    const r = createRock();
    const x = THREE.MathUtils.randFloatSpread(WORLD_SIZE-10);
    const z = THREE.MathUtils.randFloatSpread(WORLD_SIZE-10);
    r.position.set(x, heightAt(x,z)+0.25, z);
    r.rotation.set(Math.random()*0.5, Math.random()*Math.PI, Math.random()*0.5);
    rocks.add(r);
  }
  scene.add(rocks);
}

// Fireflies: 100 blinking sprites that wander. A few lightweight lights migrate among the brightest.
const fireflyGroup = new THREE.Group();
scene.add(fireflyGroup);
const FIREFLY_COUNT = 100;
const fireflies = [];
const spriteTex = (() => {
  const s = 64;
  const c = document.createElement('canvas'); c.width = c.height = s;
  const ctx = c.getContext('2d');
  const grad = ctx.createRadialGradient(s/2,s/2,0, s/2,s/2,s/2);
  grad.addColorStop(0, 'rgba(255,255,180,1)');
  grad.addColorStop(0.25, 'rgba(210,255,160,0.85)');
  grad.addColorStop(0.5, 'rgba(140,255,120,0.5)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,s,s);
  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  return tex;
})();
const fireflyMat = new THREE.SpriteMaterial({
  map: spriteTex,
  color: new THREE.Color(0x9eff6b),
  transparent: true,
  depthWrite: false,
  blending: THREE.AdditiveBlending
});

for (let i=0;i<FIREFLY_COUNT;i++){
  const spr = new THREE.Sprite(fireflyMat.clone());
  const x = THREE.MathUtils.randFloatSpread(WORLD_SIZE*0.9);
  const z = THREE.MathUtils.randFloatSpread(WORLD_SIZE*0.9);
  const y = heightAt(x,z) + THREE.MathUtils.randFloat(1.2, 3.5);
  spr.scale.set(0.6, 0.6, 0.6);
  spr.position.set(x,y,z);
  spr.material.color.setHSL(THREE.MathUtils.randFloat(0.18,0.28), 0.9, THREE.MathUtils.randFloat(0.6,0.8));
  fireflies.push({
    s: spr,
    phase: Math.random()*Math.PI*2,
    speed: THREE.MathUtils.randFloat(0.4, 1.2),
    radius: THREE.MathUtils.randFloat(6, 18),
    center: new THREE.Vector3(x, y, z)
  });
  fireflyGroup.add(spr);
}

// Migrating point lights for occasional environmental glow
const migratingLights = [];
for (let i=0;i<12;i++){
  const pl = new THREE.PointLight(0xbfff9a, 3.2, 10, 2);
  pl.castShadow = false;
  scene.add(pl);
  migratingLights.push(pl);
}

// Flashlight (SpotLight attached to camera)
const flashlight = new THREE.SpotLight(0xffffff, 30, 70, THREE.MathUtils.degToRad(18), 0.4, 2);
flashlight.castShadow = true;
flashlight.shadow.mapSize.set(1024,1024);
flashlight.shadow.bias = -0.0001;
flashlight.position.set(0, 0, 0);
flashlight.target.position.set(0, 0, -1);
const flashTarget = flashlight.target;
camera.add(flashlight);
camera.add(flashTarget);
scene.add(camera);
let flashlightOn = true;
function setFlashlight(on){
  flashlight.visible = on;
  flashlightOn = on;
  flashStateEl.textContent = on ? 'ON' : 'OFF';
}
setFlashlight(true);

// Movement
const keys = { w:false, a:false, s:false, d:false, shift:false };
addEventListener('keydown', (e) => {
  if (e.repeat) return;
  switch (e.code) {
    case 'KeyW': keys.w=true; break;
    case 'KeyA': keys.a=true; break;
    case 'KeyS': keys.s=true; break;
    case 'KeyD': keys.d=true; break;
    case 'ShiftLeft':
    case 'ShiftRight': keys.shift=true; break;
    case 'KeyF': setFlashlight(!flashlightOn); break;
    case 'KeyH':
      overlay.style.display = overlay.style.display === 'grid' ? 'none' : 'grid';
      break;
  }
});
addEventListener('keyup', (e) => {
  switch (e.code) {
    case 'KeyW': keys.w=false; break;
    case 'KeyA': keys.a=false; break;
    case 'KeyS': keys.s=false; break;
    case 'KeyD': keys.d=false; break;
    case 'ShiftLeft':
    case 'ShiftRight': keys.shift=false; break;
  }
});

const velocity = new THREE.Vector3();
const forward = new THREE.Vector3();
const right = new THREE.Vector3();
let lastTime = performance.now();

function clampToWorld(p){
  p.x = THREE.MathUtils.clamp(p.x, -HALF+1, HALF-1);
  p.z = THREE.MathUtils.clamp(p.z, -HALF+1, HALF-1);
}

function updateMovement(dt){
  const baseSpeed = 8;
  const sprint = 1.8;
  const speed = baseSpeed * (keys.shift ? sprint : 1);

  // Direction from camera
  forward.set(0,0,-1).applyQuaternion(camera.quaternion); forward.y = 0; forward.normalize();
  right.set(1,0,0).applyQuaternion(camera.quaternion); right.y = 0; right.normalize();

  const accel = new THREE.Vector3();
  if (keys.w) accel.add(forward);
  if (keys.s) accel.addScaledVector(forward, -1);
  if (keys.a) accel.addScaledVector(right, -1);
  if (keys.d) accel.add(right);
  if (accel.lengthSq()>0) accel.normalize().multiplyScalar(speed);

  // Smooth acceleration and damping
  velocity.lerp(accel, 0.18);
  // Move controls object
  const obj = controls.getObject();
  obj.position.addScaledVector(velocity, dt);

  // Clamp within borders
  clampToWorld(obj.position);

  // Stick to ground: eye height over terrain
  const groundY = heightAt(obj.position.x, obj.position.z);
  obj.position.y = groundY + PLAYER_EYE;
}

// Animate fireflies (wander + flicker)
function updateFireflies(t){
  for (let i=0;i<fireflies.length;i++){
    const f = fireflies[i];
    const s = f.s;
    // Lazy circular-ish wander around center + gentle noise
    const speed = f.speed * 0.2;
    const angle = t * speed + f.phase;
    const r = f.radius;
    const nx = Math.cos(angle) * r;
    const nz = Math.sin(angle) * r;
    const baseY = heightAt(f.center.x+nx, f.center.z+nz) + 1.2;
    s.position.set(f.center.x + nx, baseY + 1.5 + Math.sin(angle*1.7)*0.6, f.center.z + nz);

    // Flicker opacity
    const flicker = 0.55 + 0.45 * Math.abs(Math.sin(t*2.0 + f.phase*2.7));
    s.material.opacity = flicker;

    // Keep inside world
    if (Math.abs(s.position.x) > HALF-4 || Math.abs(s.position.z) > HALF-4){
      f.center.multiplyScalar(0.92); // pull back toward center
    }
  }

  // Move a few point lights to the brightest fireflies (cheap illusion)
  for (let i=0;i<migratingLights.length;i++){
    const idx = (Math.floor((t*1.5 + i*7.3)) % fireflies.length + fireflies.length) % fireflies.length;
    const ff = fireflies[idx].s;
    const pl = migratingLights[i];
    pl.color.set(ff.material.color);
    pl.intensity = 2.5 + ff.material.opacity * 2.5;
    pl.position.copy(ff.position).add(new THREE.Vector3(0, 0.1, 0));
  }
}

// Keep flashlight target aligned with camera forward
function updateFlashlight(){
  flashTarget.position.set(0, 0, -1).applyMatrix4(camera.matrixWorld);
  flashlight.position.copy(camera.position);
  flashlight.target.position.copy(flashTarget.position);
}

// Main loop
function animate(){
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt = Math.min(0.05, (now - lastTime) / 1000);
  lastTime = now;

  if (controls.isLocked){
    updateMovement(dt);
  }
  const t = now * 0.001;
  updateFireflies(t);
  updateFlashlight();

  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
